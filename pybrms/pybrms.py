# AUTOGENERATED! DO NOT EDIT! File to edit: core.ipynb (unless otherwise specified).

__all__ = ['get_brms_data', 'get_stan_code', 'fit']

# Cell
#hide
import typing
import pandas as pd
import numpy as np
import cmdstanpy
import os
import re

import rpy2.robjects.packages as rpackages
from rpy2.robjects import default_converter, pandas2ri, numpy2ri, ListVector, DataFrame, StrVector
from rpy2.robjects.conversion import localconverter

try:
    brms = rpackages.importr("brms")
except:
    utils = rpackages.importr("utils")
    utils.chooseCRANmirror(ind=1)
    utils.install_packages(StrVector(('brms',)))
    brms = rpackages.importr("brms")

# Cell
def get_brms_data(dataset_name:str):
    "A helper function for importing different datasets included in brms."
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        return pd.DataFrame(rpackages.data(brms).fetch(dataset_name)[dataset_name])

# Cell
def _convert_python_to_R(data: typing.Union[dict, pd.DataFrame]):
    """
    Converts a python object to an R object brms can handle:
    * python dict      ->   R list
    * python dataframe ->   R dataframe
    """
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        if isinstance(data, pd.DataFrame):
            return DataFrame(data)
        elif isinstance(data, dict):
            return ListVector(data)
        else:
            raise ValueError("Data should be either a pandas dataframe or a dictionary")

# Cell
def get_stan_code(
    formula: str,
    data: typing.Union[dict, pd.DataFrame],
    priors: list,
    family: str,
    sample_prior: str="no"
):
    if len(priors)>0:
        return brms.make_stancode(
            formula=formula, data=data, prior=priors, family=family, sample_prior=sample_prior
        )[0]
    else:
        return brms.make_stancode(
            formula=formula, data=data, family=family, sample_prior=sample_prior
        )[0]

# Cell
def _convert_R_to_python(
    formula: str, data: typing.Union[dict, pd.DataFrame], family: str
):
    # calls brms to preprocess the data; returns an R ListVector
    model_data = brms.make_standata(formula, data, family=family)

    # a context manager for conversion between R objects and python/pandas/numpy
    # we're not activating it globally because it conflicts with creation of priors
    with localconverter(default_converter + pandas2ri.converter + numpy2ri.converter) as cv:
        model_data = dict(model_data.items())
    return model_data

# Cell
def _coerce_types(stan_code, stan_data):
    pat_data = re.compile(r'(?<=data {)[^}]*')
    pat_identifiers = re.compile(r'([\w]+)')

    # extract the data block and separate lines
    data_lines = pat_data.findall(stan_code)[0].split('\n')

    # remove commets, <>-style bounds and []-style data size declarations
    data_lines_no_comments = [l.split('//')[0] for l in data_lines]
    data_lines_no_bounds = [re.sub('<[^>]+>', '',l) for l in data_lines_no_comments]
    data_lines_no_sizes = [re.sub('\[[^>]+\]', '',l) for l in data_lines_no_bounds]

    # extract identifiers - first one should be the type, last one should be the name
    identifiers = [pat_identifiers.findall(l) for l in data_lines_no_sizes]
    var_types = [l[0] for l in identifiers if len(l)>0]
    var_names = [l[-1] for l in identifiers if len(l)>0]
    var_dict = dict(zip(var_names, var_types))

    # coerce integers to int and 1-size arrays to scalars
    def coerce(k,v):
        if k in var_names and var_dict[k]=="int":
            v = v.astype(int) # np.int32) # hmm, why did i change this ?
        if v.size==1:
            v, = v.ravel()
        return v

    return {k: coerce(k,v) for k,v in stan_data.items()}


# Cell
def fit(
    formula: str,
    data: typing.Union[dict, pd.DataFrame],
    priors: list = [],
    family: str = "gaussian",
    sample_prior: str = "no",
    sample: bool = True,
    name: str = None,
    outdir: str = ".",
    stan_exe_file: str = None,
    **stan_args,
):
    data = _convert_python_to_R(data)

    # no executable passed -- compile model
    if stan_exe_file is None:
        formula = brms.bf(formula)

        if len(priors)>0:
            brms_prior = brms.prior_string(*priors[0])
            for p in priors[1:]:
                brms_prior = brms_prior + brms.prior_string(*p)
            assert brms.is_brmsprior(brms_prior)
        else:
            brms_prior = []

        model_code = get_stan_code(
            formula=formula,
            data=data,
            family=family,
            priors=brms_prior,
            sample_prior=sample_prior,
        )

        fname = name if name is not None else 'model'
        stan_file = f'{outdir}/{fname}.stan'
        with open(os.path.abspath(stan_file), 'w') as f:
            f.write(model_code)

        kwargs = {'stan_file': stan_file}

    # load precompiled executable
    else:
        with open(os.path.abspath(f'{stan_exe_file}.stan'), 'r') as f:
            model_code = f.read()

        # allow model name to differ from exe name --
        # this is essential if using same exe to sample given multiple datasets in parallel
        # but depends on removing this check from `cmdstanpy`
        name = name if name is not None else stan_exe_file
        kwargs = {'exe_file': stan_exe_file, 'compile': False}

    model_data = _convert_R_to_python(formula, data, family)
    model_data = _coerce_types(model_code, model_data)

    sm = cmdstanpy.CmdStanModel(model_name=name, **kwargs)
    if not sample:
        return sm
    else:
        fit = sm.sample(data=model_data, output_dir=outdir, **stan_args)
        return fit
